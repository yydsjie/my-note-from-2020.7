快速幂求逆元：

基本原理：

乘法逆元：若b,n互质，并且对任意整数a，满足b|a,则存在一个整数x，使得a/b≡a×x(mod m),则称x为b模m的乘法逆元。

简化：a/b≡a*x(mod m)可化为b*x≡1(mod m)由费马引理可得b,m互质则有b^(m-1)≡1(mod m)  所以 b*b^(m-2)≡1(mod m)  所以b^(m-2)就为b模m的乘法逆元（要模m得到最小，这样才唯一）。
这样就可以使用快速幂做法，因为是求b^(m-2)。

无解情况：b和m不互质，那么b是m的质数，所以不存在。

样例：

#include<iostream>
  
#include<algorithm>

using namespace std;

typedef long long LL;


//求a^k%p
  
int qmi(int a,int k,int p)
  
{
  
    int res = 1;
  
    while(k)
  
    {
  
    if(k&1)  res=(LL)res*a%p;
    
    k>>=1;
    
    a=(LL)a*a%p;  //下个a^xn等于上个的平方
  
    }
    
    return res;
  
}
  
int main()
  
{
  
    int n;
   
    scanf("%d",&n);
    
    while(n--)
  
    {
  
    int a,p;
  
    scanf("%d%d",&a,&p);
  
    int res = qmi(a,p-2,p);
  
    if(a%p)      //p=2，res返回1，不能用qmi的值判断
  
    printf("%d\n",res);
  
    else printf("impossible\n");
  
    }
    
    return 0;
  
}
