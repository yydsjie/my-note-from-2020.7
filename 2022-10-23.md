中国剩余定理：

基本原理：

假设m1,m2...,mn两两互质，并且有如下关系：

X≡a1(mod m1)

X≡a2(mod m2)

...

定义M=m1*m2*..*mn，Mi=M/mi,Mi^-1表示Mi的乘法逆元.

就有x=a1*Mi*MI^-1...+an*Mn*Mn^-1.因为Mi是M除过mi的乘积所以除了ai*Mi*Mi^-1其余项mod mi均为0，Mi*Mi^-1 mod mi =1,所以满足上述每一条关系。

推导过程：

X=k1*a1+m1,x=k2*a2+m2

K1*a1+m1=k2*a2+m2,可变形为:k1*a1-k2*a2=m2-m1,可通过拓展欧几里得算法,求出k1,k2的值,也可得出判定其有解的条件（满足gcd(a1,a2)|（m1-m2）)

可以知道其通解

(1)k1+k*a2/d     (2)k2+k*a1/d    带入上式 (k1*a1-k2*a2=m2-m1) 是依然成立的

X=(k1 + k*a2/d )*a1 + m1 =k1*a1+m1+ k*[a1*a2]/d 

(正好为a1,a2最小公倍数用a表示)

令x0=k1*a1+m1,x=x0+k*a.

这是两个式子的合并，那么n个式子可以通过n-1次合并成一个式子（x=k*a+x0的形式），然后就有x0=x%a.

#include<iostream>
  
#include<algorithm>

using namespace std;

typedef long long LL;


LL exgcd(LL a,LL b,LL &x,LL &y)
{
    
    if(!b) 
  
    {
  
        x=1,y=0;
  
        return a;
  
    }
    
    LL d = exgcd(b,a%b,y,x);
    
    y-=(a/b)*x;
    
    return d;
  
}


int main()
  
{
  
    int n;
  
    scanf("%d",&n);
    
    bool has_answer = true;
  
    LL a1,m1;
  
    cin>>a1>>m1;
    
    for(int i=1;i<n;i++)
                         
    {
                         
        LL a2,m2;
        
        cin>>a2>>m2;
        
        LL k1,k2;
        
        LL d=exgcd(a1,a2,k1,k2);
        
        if((m2-m1)%d)   //成立条件：(m2-m1)整除以d
  
        {
  
            has_answer = false;
  
            break;
  
        }
        
        k1*=(m2-m1)/d;//求出来的k1是关于d的解所以需要*(m2-m1)/d
        
        LL t = a2/d;           //k1的通解形式是k1+a2/d 的形式，所以其最小解mod t就行
  
        k1=(k1 % t + t) % t;   //本质就是k mod t 但可能有负值存在
        
        m1=a1*k1+m1;
  
        a1=abs(a1/d*a2);   //取最大公倍数
        
    }
    
    if(has_answer)
  
    {
  
        cout<<(m1 % a1 +a1)%a1<<endl;
  
    }
  
    else printf("-1\n");
    
    return 0;
  
}
