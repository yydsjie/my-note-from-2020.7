求组合数

I基本原理

Cab=Ca-1b-1+Ca-1b；（a在下，b在上）

假设我们有a个苹果，那么可标记其中一个苹果为红苹果，那么所有的选择方法就可以分为包含红苹果的分类和不包含红苹果的分类，

那么其选法分别为:Ca-1b-1(包含红苹果的分类即已经选出一个为红苹果那么要再从剩下当中再选b-1个)和Ca-1b（不包含红苹果的分类即在剩下的苹果中选出需要个数b）。
样例：

#include<iostream>
  
#include<algorithm>

using namespace std;

const int N = 2010,mod=1e9+7;

int c[N][N];

void init()
  
{
  
    for(int i=0;i<N;i++)
                         
    for(int j=0;j<=i;j++)
  
    if(!j) c[i][j]=1;
  
    else  c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;  
  
}
  
int main()
  
{
  
    init();
    
    int n;
    
    scanf("%d",&n);
  
    while(n--)
  
    {
  
        int a,b;
  
        scanf("%d%d",&a,&b);
  
        printf("%d\n",c[a][b]);
  
    }
  
    return 0;
  
}
  
2基本原理：
  
如果求的数据再次增大上面求组合数的方法效率就会偏慢，所以有另一种求组合数的方法。
  
Cab=a!/(b!*(a-b)!)，可以预处理分别求出相应a!modp,b! mod p的乘法逆元x,(a-b)! mod p的乘法逆元y,Cab=(a!%p)*x mod p*y mod p.(乘法逆元用快速幂求出)。
  
样例：

#include<iostream>
  
#include<algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5+10,mod = 1e9+7;

int fact[N],infact[N];

int qmi(int a,int k,int p)     //快速幂求乘法逆元
  
{
  
    int res=1;
    
    while(k)
  
    {
  
        if(k&1)  res=(LL)res*a%p;
  
        a=(LL)a*a%p;
  
        k=k>>1;
  
    }
    
    return res;
  
}

int main()
  
{
  
    fact[0]=infact[0]=1;
  
    for(int i=1;i<N;i++)
                         
    {
                         
        fact[i]=(LL)fact[i-1]*i%mod;
                         
        infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;
                         
    }
    
    int n;
                         
    scanf("%d",&n);
    
    while(n--)
                         
    {
                         
        int a,b;
                         
        scanf("%d%d",&a,&b);
                         
        printf("%d\n",(LL)fact[a] * infact[b] % mod * infact[a-b] % mod); 
                         
    }
    
    return 0;
                         
}
